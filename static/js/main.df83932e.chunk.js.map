{"version":3,"sources":["api/client.js","features/notifications/notificationsSlice.js","app/Navbar.js","features/posts/postsSlice.js","features/api/apiSlice.js","features/users/usersSlice.js","features/posts/PostAuthor.js","features/posts/TimeAgo.js","features/posts/ReactionButtons.js","components/Spinner.js","features/posts/PostsList.js","features/posts/AddPostForm.js","features/posts/SinglePostPage.js","features/posts/EditPostForm.js","features/users/UserPage.js","features/users/UsersList.js","features/notifications/NotificationsList.js","App.js","api/server.js","app/store.js","index.js"],"names":["client","endpoint","body","customConfig","headers","config","method","JSON","stringify","window","fetch","response","json","data","ok","status","url","Error","statusText","Promise","reject","message","get","post","fetchNotifications","createAsyncThunk","_","getState","allNotifications","selectAllNotifications","latestNotification","latestTimestamp","date","notificationAdapter","createEntityAdapter","sortComparer","a","b","localeCompare","notificationsSlice","createSlice","name","initialState","getInitialState","reducers","allNotificationsRead","state","action","Object","values","entities","forEach","notification","read","extraReducers","builder","addCase","fulfilled","upsertMany","payload","isNew","actions","getSelectors","notifications","selectAll","Navbar","unreadNotificationsBadge","dispatch","useDispatch","numUnreadNotifications","useSelector","filter","length","className","to","onClick","postsAdapter","error","fetchPosts","addNewPost","initialPost","postsSlice","reactionAdded","postId","reaction","existingPost","reactions","postUpdated","id","title","content","pending","addOne","rejected","postAdded","posts","selectAllPosts","selectPostByUser","selectById","selectIds","createSelector","userId","user","apiSlice","createApi","reducerPath","baseQuery","fetchBaseQuery","baseUrl","tagTypes","endpoints","getPosts","query","providesTags","result","map","type","getPost","arg","mutation","invalidatesTags","editPost","useGetPostsQuery","useGetPostQuery","useAddNewPostMutation","useEditPostMutation","usersAdapter","fetchUsers","usersSlice","setAll","users","selectAllUsers","selectUserById","PostAuthor","author","TimeAgo","timestamp","timeAgo","parseISO","timePeriod","formatDistanceToNow","reactionEmoji","thumbsUp","hooray","heart","rocket","eyes","ReactionButtons","reactionButtons","entries","emoji","Spinner","text","size","header","style","height","width","PostExcerpt","substring","PostsList","isLoading","isFetching","isSuccess","isError","refetch","sortedPosts","useMemo","slice","sort","renderPosts","containerClassname","cn","disabled","toString","AddPostForm","useState","setTitle","setContent","setUserId","setRequestStatus","canSave","every","Boolean","onSavePostClicked","unwrap","console","usersOptions","value","htmlFor","onChange","e","target","SinglePostPage","match","params","marginTop","EditPostForm","updatePost","history","useHistory","push","placeholder","UserPage","postTitles","UsersList","renderUsers","NotificationsList","useLayoutEffect","renderNotifications","find","notificationClassname","classnames","new","App","seedDate","exact","path","render","component","configureStore","reducer","postsReducer","usersReducer","middleware","getDefaultMiddleware","concat","ARTIFICIAL_DELAY_MS","rng","seedrandom","randomSeedString","localStorage","getItem","getRandomInt","min","max","Math","ceil","floor","Date","toISOString","setItem","setRandom","faker","seed","getTime","randomFromArray","array","db","factory","primaryKey","nanoid","firstName","String","lastName","username","manyOf","oneOf","comments","comment","Number","createUserData","internet","userName","i","create","j","newPost","lorem","words","recent","paragraphs","serializePost","handlers","rest","req","res","ctx","getAll","delay","findFirst","where","equals","patch","updatedPost","update","generateRandomNotifications","undefined","worker","setupWorker","socketServer","MockSocketServer","sendRandomNotifications","socket","since","obj","send","sendMessage","on","parse","notificationTemplates","numNotifications","pastDate","now","valueOf","setMinutes","getMinutes","Array","template","between","start","onUnhandledRequest","store","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.df83932e.chunk.js","sourcesContent":["// A tiny wrapper around fetch(), borrowed from\n// https://kentcdodds.com/blog/replace-axios-with-a-simple-custom-fetch-wrapper\n\nexport async function client(endpoint, { body, ...customConfig } = {}) {\n  const headers = { 'Content-Type': 'application/json' }\n\n  const config = {\n    method: body ? 'POST' : 'GET',\n    ...customConfig,\n    headers: {\n      ...headers,\n      ...customConfig.headers,\n    },\n  }\n\n  if (body) {\n    config.body = JSON.stringify(body)\n  }\n\n  let data\n  try {\n    const response = await window.fetch(endpoint, config)\n    data = await response.json()\n    if (response.ok) {\n      // Return a result object similar to Axios\n      return {\n        status: response.status,\n        data,\n        headers: response.headers,\n        url: response.url,\n      }\n    }\n    throw new Error(response.statusText)\n  } catch (err) {\n    return Promise.reject(err.message ? err.message : data)\n  }\n}\n\nclient.get = function (endpoint, customConfig = {}) {\n  return client(endpoint, { ...customConfig, method: 'GET' })\n}\n\nclient.post = function (endpoint, body, customConfig = {}) {\n  return client(endpoint, { ...customConfig, body })\n}\n","import { createSlice, createAsyncThunk, createEntityAdapter } from '@reduxjs/toolkit';\nimport { client } from '../../api/client.js';\n\nexport const fetchNotifications = createAsyncThunk(\n  'notifications/fetchNotifications',\n  \n  // Мы можем передать аргумент создателю действия thunk, когда мы его отправляем, например dispatch(addPost(newPost)).\n  async (_, { getState }) => { \n    \n    // В createAsyncThunk, вы можете передать только один аргумент, и все, что мы передаем, \n    // становится первым аргументом обратного вызова создания полезной нагрузки.\n    \n    // Второй аргумент нашему создателю полезной нагрузки — это thunkAPI объект \n    // {\n    //   dispatch/getState:  Фактические dispatchи getStat eметоды из нашего магазина Redux. \n    //                       Вы можете использовать их внутри thunk для отправки дополнительных действий \n    //                       или получения последнего состояния хранилища Redux \n    //                       (например, чтение обновленного значения после отправки другого действия).\n                      \n    //   extra:              «Дополнительный аргумент», который можно передать в thunk middleware при создании хранилища. \n    //                       Обычно это какая-то оболочка API, такая как набор функций, которые знают, как выполнять вызовы API на сервер \n    //                       вашего приложения и возвращать данные, поэтому вашим thunk'aм не нужно иметь все URL-адреса и логику запросов непосредственно внутри\n    \n    //   requestId:          Уникальное случайное значение идентификатора для этого вызова thunk'a. Полезно для отслеживания статуса отдельного запроса.\n\n    //   signal:             AbortController.signal функция, которую можно использовать для отмены выполняемого запроса.\n                      \n    //   rejectWithValue:    Утилита, которая помогает настроить содержимое rejected действия, если thunk получает ошибку.\n    // }\n\n    // Если вы пишете преобразователь вручную вместо использования createAsyncThunk, функция преобразователя \n    // будет получать (dispatch, getState)отдельные аргументы, а не объединять их в один объект.\n    // INFO: https://redux.js.org/tutorials/essentials/part-6-performance-normalization#thunk-arguments\n    //       https://redux-toolkit.js.org/api/createAsyncThunk\n\n    const allNotifications = selectAllNotifications(getState());\n    const [latestNotification] = allNotifications; // Получаем самый первый объект уведомления в массиве (свежее уведомление находится в начале массива)\n    const latestTimestamp = latestNotification ? latestNotification.date : '';\n    const response = await client.get(`/fakeApi/notifications?since=${latestTimestamp}`)\n    return response.data;\n  }\n)\n\nconst notificationAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.date.localeCompare(a.date) // Сортируем массив объектов так, чтобы объект уведомления с самой свежей датой оказался первым.\n});\n\nexport const notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState: notificationAdapter.getInitialState(),\n  reducers: {\n    allNotificationsRead(state, action) {\n      Object.values(state.entities).forEach((notification) => {\n        notification.read = true;\n      })\n    }\n  },\n  extraReducers(builder) {\n    builder\n      .addCase(fetchNotifications.fulfilled, (state, action) => {\n        notificationAdapter.upsertMany(state, action.payload); // принимает массив сущностей или объект, выполнит поверхностную копию, \n        // чтобы объединить старые и новые объекты, перезаписав существующие значения, добавив все, чего не было, и не касаясь свойств, не представленных в новом объекте.\n        // state.push(...action.payload); Аналог\n        \n        Object.values(state.entities).forEach(notification => {\n          notification.isNew = !notification.read; // Любые уведомления, которые мы прочитали, больше не являются новыми\n        })\n      })\n  }\n})\n\nexport const { allNotificationsRead } = notificationsSlice.actions;\n\nexport default notificationsSlice.reducer;\n\nexport const { selectAll: selectAllNotifications } = \n  notificationAdapter.getSelectors((state) => state.notifications)\n// export const selectAllNotifications = (state) => state.notifications;","import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { Link } from 'react-router-dom';\nimport { selectAllNotifications } from '../features/notifications/notificationsSlice';\n\nimport { fetchNotifications } from '../features/notifications/notificationsSlice';\n\nexport const Navbar = () => {\n  const dispatch = useDispatch();\n  const notifications = useSelector(selectAllNotifications)\n  const numUnreadNotifications = notifications.filter((notification) => notification.isNew).length\n\n  \n  const fetchNewNotifications = () => {\n    dispatch(fetchNotifications());\n  }\n  \n  let unreadNotificationsBadge\n\n  if (numUnreadNotifications > 0) {\n    unreadNotificationsBadge = <span className=\"badge\">{numUnreadNotifications}</span>\n  }\n  \n  return (\n    <nav>\n      <section>\n        <h1>Redux Essentials Example</h1>\n\n        <div className=\"navContent\">\n          <div className=\"navLinks\">\n            <Link to=\"/\">Posts</Link>\n            <Link to=\"/users\">Users</Link>\n            <Link to=\"/notifications\">Notifications {unreadNotificationsBadge}</Link>\n          </div>\n          <button className=\"button\" onClick={fetchNewNotifications}>\n            Refresh Notifications\n          </button>\n        </div>\n      </section>\n    </nav>\n  )\n}\n","import { createSlice, createAsyncThunk, createSelector, createEntityAdapter } from '@reduxjs/toolkit';\nimport { client } from '../../api/client';\n// import { sub } from 'date-fns';\n\n// const initialState = [\n  // { \n    // id: '1', \n    // title: 'First Post!', \n    // content: 'Hello!', \n    // date: sub(new Date(), { minutes: 10}).toISOString(),\n    // reactions: {thumbsUp: 0, hooray: 0, heart: 0, rocket: 0, eyes: 0}\n  // },\n  // { id: '2', \n    // title: 'Second Post', \n    // content: 'More text', \n    // date: sub(new Date(), { minutes: 5}).toISOString(),\n    // reactions: {thumbsUp: 0, hooray: 0, heart: 0, rocket: 0, eyes: 0}\n  // },\n// ];\n\n\n\nconst postsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n});\n\n\n// const initialState = {\n//   posts: [],\n//   status: 'idle', // Состояние загрузки обычно должно храниться как перечисление, например 'idle' | 'loading' | 'succeeded' | 'failed'\n//   error: null,\n// };\n\nconst initialState = postsAdapter.getInitialState({\n  status: 'idle',\n  error: null,\n})\n// getInitialState === { ids: [], entities: {}, + status: 'idle', + error: null }\n\n\n \n// Результат вызова createAsyncThunk одна функция fetchPosts, имеющая три свойства fetchPosts.(pending|fulfilled|rejected)\n// 1)fetchPosts - выполняет колбек функцию (из второго аргумента), но перед выполнением она вызовет внутр. свойство(функция) fetchPosts.pending() для отправки типа действия 'posts/fetchPosts/pending'\n// 2)fetchPosts.pending() 3)fetchPosts.fulfilled()  4)fetchPosts.rejected() - три функции создателя действия, используются для определения статуса выполнения thunk'a\n// и его обработки в createSlice({ extraReducers(builder): { ТУТ-> builder.addCase() } })\n\n// API: https://redux-toolkit.js.org/api/createAsyncThunk#overview\n// Гайд: https://redux.js.org/tutorials/essentials/part-5-async-logic#fetching-data-with-createasyncthunk\n// Возвращаемое значение фун. createAsyncThunk: https://redux-toolkit.js.org/api/createAsyncThunk#return-value\n\nexport const fetchPosts = createAsyncThunk( // // fetchPosts- выполняет ajax запрос на сервер(имитация) для получения списка сообщений.\n  'posts/fetchPosts',\n  // 'posts/fetchPosts' - использоваться в качестве префикса для генерации трех типов действий 'posts/fetchPosts/(pending|fulfilled|rejected)'.\n  \n  async () => {\n    // колбек «создатель полезной нагрузки», который должен возвращать Promise.\n    // Перед началом выполнения эта функция всегда вызывает создатель действия fetchPosts.pending(), \n    // чтобы указать хранилищу о начале выполнения thunk'a, который сразу будет прослушан в extraReducer\n    // Результат выполнения: Promise c данными и вызов fetchPosts.fulfilled() ИЛИ отклоненный Promise с ошибкой и вызов fetchPosts.rejected() \n    // не забудь про всплытие ошибки из rejected, для этого нужно юзать  .unwrap() https://redux-toolkit.js.org/api/createAsyncThunk#unwrapping-result-actions\n    const response = await client.get('/fakeApi/posts');\n    return response.data;\n  },\n  // Третий аргумент options объект (необязательно).\n) // Всё удобство createAsyncThunk API в том, что отправкой действий он занимается самостоятельно.\n\nexport const addNewPost = createAsyncThunk(\n  'posts/addNewPost',\n  async (initialPost) => { // параметр - объект. Он содержащий данные из формы наход. в компоненте AddPostForm.js\n    const response = await client.post('/fakeApi/posts', initialPost);\n    return response.data;\n  }\n)\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState, // from getInitialAdapter\n  reducers: {\n    // Когда мы пишем postAdded функцию редюсера, createSlice автоматически создает функцию создания действия с тем-же именем, что и у редюсера.\n    // postAdded: {\n    //   reducer(state, { payload }) {\n    //     state.posts.push(payload) // это мутация. Она преобразуются в безопасные неизменяемые обновления за счет Immer'a\n    //   },\n    //   prepare(title, content, userId) { // или 'prepare callback', вызывается перед вызовом  reducer, чтобы подготовить данные экшена. \n    //     return { // Результат выполнения функции prepare объект action, который прокидывается во второй аргумент функции reducer выше. \n    //       payload: {\n    //         id: nanoid(), // Уникальные идентификаторы и другие случайные значения положено вычислять до попадания в редьюсер. Редюсер должен содержать основную логику.\n    //         date: new Date().toISOString(), // Создание даты и её трансформация в формат ISO. (гг.мм.дд)\n    //         title,\n    //         content,\n    //         user: userId,\n    //         reactions: {thumbsUp: 0, hooray: 0, heart: 0, rocket: 0, eyes: 0},\n    //       }\n    //     }\n    //   },\n    // },\n    reactionAdded: (state, action) => {\n      const { postId, reaction } = action.payload;\n      // Используя нормализованную структуру данных, которая создана при помощи createEntityAdapter > .getInitialState\n      // мы уходим от поиска (On) и повышаем производительность\n      // const existingPost = state.posts.find(post => post.id === postId);\n      const existingPost = state.entities[postId];\n      if(existingPost) {\n        existingPost.reactions[reaction]++\n      }\n    },\n    postUpdated: (state, action) => {\n      const { id, title, content } = action.payload;\n      // const existingPost = state.posts.find((post) => post.id === id);\n      const existingPost = state.entities[id];\n      if (existingPost) {\n        existingPost.title = title;\n        existingPost.content = content;\n      }\n    }\n  },\n  // Обрабатывает/прослушивает три фун. (создатели действия), которые порождает функция \"createAsyncThunk\"\n  extraReducers(builder) { \n    // Гайд: https://redux.js.org/tutorials/essentials/part-5-async-logic#reducers-and-loading-actions\n    builder\n    // Перед выполнением фун. fetchPosts вызывает функцию fetchPosts.pending (создатель действия), которая посылает тип действия 'posts/fetchPosts/pending'\n    // этот тип действия отлавливатся и обрабатыватся в соответ. обработчике, в нашем случе в .addCase(fetchPosts.pending, ... )\n      .addCase(fetchPosts.pending, (state, action) => { // т.е. ТУТ\n          state.status = 'loading'; \n        })\n      .addCase(fetchPosts.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        // state.posts = state.posts.concat(action.payload); // Аналог .upsertMany\n        postsAdapter.upsertMany(state, action.payload);\n        // редьюсер upsertMany как утилиту выполняющая мутирующие обновления.\n        // Он добавляет все входящие сообщения в состояние, передав черновик state и массив сообщений в action.payload\n        // Если в этом состоянии уже есть какие-либо элементы action.payload, upsertManyфункция объединит их вместе на основе совпадающих идентификаторов.\n      })\n   // .addCase(addNewPost.fulfilled, (state, action) => {\n   //   state.posts.push(action.payload);\n   // })\n      .addCase(addNewPost.fulfilled, postsAdapter.addOne) // addOne готовый метода для добавления данных в стейт\n      .addCase(fetchPosts.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message;\n      })\n   }\n});\n\n\n// createSlice будет генерировать (автоматически за кулисами) функции создания объекта действия для каждого редьюсера, который мы добавляем в слайс\n// имя функции для создания действия совпадает с именем редюсера.\nexport const { postAdded, postUpdated, reactionAdded } = postsSlice.actions;\n\nexport default postsSlice.reducer;\n\n// Пользовательские селекторы\n// Селекторы в основном используются для инкапсуляции логики поиска определенных значений из состояния, \n// логики фактического получения значений и повышения производительности за счет исключения дублирования кода в других компонентах.\n// export const selectAllPosts = (state) => state.posts.posts; // state === store.getState() из useDispatch()\n// export const selectPostById = (state, postId) => state.posts.posts.find(post => post.id === postId)\nexport const {\n  selectAll: selectAllPosts,\n  selectById: selectPostById,\n  selectIds: selectPostIds\n} = postsAdapter.getSelectors(state => state.posts);\n// {selectIds: ƒ, selectEntities: ƒ, selectAll: ƒ, selectTotal: ƒ, selectById: ƒ} = postsAdapter.getSelectors(state => state.posts)\n// Заменяет написанные от руки selectAllPostsи selectPostById селекторные функции на сгенерированные postsAdapter.getSelectors. \n// Поскольку селекторы вызываются с корневым объектом состояния Redux, им нужно знать, где найти данные наших сообщений в состоянии Redux, \n// поэтому мы передаем небольшой селектор, который возвращает state.posts \n// Сгенерированные функции селекторов всегда вызываются selectAllи selectById, поэтому мы можем использовать синтаксис деструктуризации ES6, \n// чтобы переименовывать их при экспорте и сопоставлять старые имена селекторов.\n\n\n// createSelector Генерирует запоминаемые селекторы, которые будут пересчитывать результаты только при изменении входных данных.\n// Если мы попытаемся вызвать selectPostsByUser несколько раз, он будет повторно запускать селектор вывода только в том случае, если что-либо postsили userId изменилось\n// createSelector API: https://redux.js.org/usage/deriving-data-selectors#createselector-overview \n\n// createSelector это функция изначально находится в библиотеки Reselect, но для удобства её добавили в пакет Redux-toolkit\n// Reselect: https://github.com/reduxjs/reselect\n\nexport const selectPostByUser = createSelector( \n  // Когда мы вызываем selectPostsByUser(state, userId), createSelector передаем все аргументы в каждый из наших селекторов ввода. \n  [\n    selectAllPosts, // Первый входной селектор будет иметь параметры (state и userId)\n    (state, userId) => userId // Второй входной селектор получит такие же параметры при вызове (state, userId)\n  ], \n  \n  // Результат первого входного селектора будет posts, результат второго селектора будет userId\n  (posts, userId) => posts.filter(post => post.user === userId)  \n)","import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n  // Если вы не укажете reducerPath параметр, по умолчанию он будет 'api' \n  reducerPath: 'api', // store: state.api\n\n  // Все наши запросы будут иметь URL-адреса, начинающиеся с «/fakeApi».\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  // fetchBaseQuery - Небольшая оболочка fetch, предназначенная для упрощения запросов.\n\n  tagTypes: ['Post'], // здесь нет ничего особенного в литеральной строке 'Post'\n  // Мы могли бы назвать это 'Fred', 'qwerty' или как-нибудь еще. Просто в каждом поле должна\n  // быть одна и та же строка, чтобы RTK Query знал, что «когда произойдет эта мутация, сделать\n  // недействительными все конечные точки, в которых указана одна и та же строка тега».\n\n  // «Конечные точки» представляют собой операции и запросы для этого сервера.\n  // По умолчанию конечные точки запроса будут использовать GET HTTP-запрос\n  // Для переопределения, вернуть объект, типа: {url: '/posts', method: 'POST', body: newPost} вместо самой строки URL\n  endpoints: builder => ({\n    getPosts: builder.query({\n      query: () => '/posts',  // URL для запроса: '/fakeApi/posts'\n      \n      // providesTags: ['Post'], // конечная точка getPosts предоставляет тег 'Post'\n      // а addNewPost конечная точка мутации делает этот тег недействительным.\n      \n      providesTags: (result = [], error, arg) => [\n        'Post',\n        ...result.map(({id}) => ({ type: 'Post', id }))\n      ]\n      // Поле providesTags также может принимать функцию обратного вызова, которая получает result,\n      // arg и возвращает массив.  Это позволяет нам создавать записи тегов на основе идентификаторов\n      // извлекаемых данных. Точно так же invalidatesTagsможет быть и обратный вызов.\n      // т.е. мы сможем выборочно анулировать данные в кэше, т.е. в списке posts где лежит сущность каждого\n      // поста ввиде объекта, в котором есть id, title, content и тд.\n    }),\n    getPost: builder.query({\n      query: (postId) => `/posts/${postId}`,\n      providesTags: (result, error, arg) => [{ type: 'Post', id: arg }]\n    }),\n    addNewPost: builder.mutation({\n      query: (initialPost) => ({\n        url: '/posts',\n        method: 'POST',\n        body: initialPost // передаем полезную нагрузку (новый пост) в тело запроса\n      }),\n      // Здесь наша query опция возвращает объект, содержащий {url, method, body}.\n      // Поскольку мы используем fetchBaseQuery для выполнения запросов, body поле \n      // будет автоматически сериализовано для нас в формате JSON.\n\n      invalidatesTags: ['Post'], // Массив тегов, которые станут недействительными, каждый раз когда запустится мутация\n      // Это позволит автоматически обновлять  getPosts конечную точку каждый раз, когда мы добавляем новый пост\n      // т.е. мы делаем недействительными данные в кэше полученные с запроса /fakeApi/posts\n    }),\n    editPost: builder.mutation({\n      query: (post) => ({\n        url: `/posts/${post.id}`,\n        method: 'PATCH',\n        body: post,\n      }),\n      invalidatesTags: (result, error, arg) => [{ type: 'Post', id: arg.id}]\n    }),\n  }),\n});\n\n// Экспортируем автоматически сгенерированный хук для конечной точки запроса `getPosts`\n// Ведь RTKQ-react автоматически генерирует хуки для каждой созданной нами конечной точки!\nexport const {\n  useGetPostsQuery,\n  useGetPostQuery,\n  useAddNewPostMutation, // endpoint addNewPost: builder. > mutation <\n  useEditPostMutation,\n} = apiSlice;\n\n\n// Почему именно useGetPostsQuery ?\n// Хуки автоматически именуются на основе стандартного соглашения:\n// use - префикс, говорящий что это хук React'а\n// Имя конечной точки, с заглавной буквы\n// Тип конечной точки Query или Mutation","import { createSlice, createAsyncThunk, createEntityAdapter } from '@reduxjs/toolkit';\nimport { client } from '../../api/client';\n\nconst usersAdapter = createEntityAdapter(); // объект с настройками не нужен, по этому ничего не передаем.\n\n// const initialState = [\n//   { id: '0', name: 'Tianna Jenkins' },\n//   { id: '1', name: 'Kevin Grant' },\n//   { id: '2', name: 'Madison Price' }\n// ]\n// const initialState = [];\nconst initialState = usersAdapter.getInitialState(); // {entities: {}, ids:[]}\n\n\nexport const fetchUsers = createAsyncThunk(\n  'users/fetchUsers',\n  async () => {\n    const response = await client.get('/fakeApi/users');\n    return response.data\n  }\n)\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {},\n  extraReducers(builder) {\n    builder\n      // .addCase(fetchUsers.fulfilled, (state, action) => {\n        // state.push(...action.payload) может привести к дублированию списка пользователей\n        // return action.payload; // Immer полностью заменяет initialState новым объектом\n      // })\n      .addCase(fetchUsers.fulfilled, usersAdapter.setAll)\n  }\n});\n\nexport default usersSlice.reducer;\n\n// export const selectAllUsers = (state) => state.users;\n// export const selectUserById = (state, userId) => state.users.find((user) => user.id === userId);\nexport const {\n  selectAll: selectAllUsers,\n  selectById: selectUserById,\n} = usersAdapter.getSelectors((state) => state.users);","import React from 'react';\nimport { useSelector } from 'react-redux';\nimport { selectUserById } from '../users/usersSlice.js';\n\nexport const PostAuthor = ({ userId }) => {\n  const author = useSelector(state => selectUserById(state, userId));\n  return <span>by {author ? author.name : 'Unknown author'}</span>\n}","import React from 'react';\nimport { parseISO, formatDistanceToNow } from 'date-fns';\n\nexport const TimeAgo = ({ timestamp }) => {\n  let timeAgo = '';\n  if (timestamp) {\n    const date = parseISO(timestamp);\n    const timePeriod = formatDistanceToNow(date);\n    timeAgo = `${timePeriod} ago`\n  }\n\n  return (\n    <span title={timestamp} >\n      &nbsp; <i>{timeAgo}</i>\n    </span>\n  )\n}","import React from 'react';\nimport { useDispatch } from 'react-redux';\n\nimport { reactionAdded } from './postsSlice';\n\nconst reactionEmoji = {\n  thumbsUp: '👍',\n  hooray: '🎉',\n  heart: '❤️',\n  rocket: '🚀',\n  eyes: '👀'\n}\n\nexport const ReactionButtons = ({ post }) => {\n  const dispatch = useDispatch();\n  \n  const reactionButtons = Object.entries(reactionEmoji).map(([name, emoji]) => {\n    return (\n      <button \n        key={name} \n        type=\"button\" \n        className=\"muted-button reaction-button\" \n        onClick={() => \n          dispatch(reactionAdded({ postId: post.id, reaction: name }))\n        }\n      >\n        {emoji} {post.reactions[name]}\n      </button>\n    )\n  });\n\n  return <div>{reactionButtons}</div>\n}","import React from 'react'\n\nexport const Spinner = ({ text = '', size = '5em' }) => {\n  const header = text ? <h4>{text}</h4> : null\n  return (\n    <div className=\"spinner\">\n      {header}\n      <div className=\"loader\" style={{ height: size, width: size }} />\n    </div>\n  )\n}\n","import React, { useEffect, useMemo } from 'react';\n\nimport cn from 'classnames';\n\nimport { useSelector, useDispatch } from 'react-redux';\nimport { \n  selectAllPosts,\n  fetchPosts,\n  selectPostIds,\n  selectPostById,\n} from './postsSlice';\n\nimport { useGetPostsQuery } from '../api/apiSlice';\n\nimport { Link } from 'react-router-dom';\nimport { PostAuthor } from './PostAuthor.js';\nimport { TimeAgo } from './TimeAgo.js';\nimport { ReactionButtons } from './ReactionButtons.js';\nimport { Spinner } from '../../components/Spinner.js';\n\n// const PostExcerpt = ({ postId }) => { // после RTK\n//   const post = useSelector((state) => selectPostById(state, postId)); \n  \n//   return (\n//     <article className=\"post-excerpt\" key={post.id}>\n//       <h3>{post.title}</h3>\n//       <div>\n//         <PostAuthor userId={post.user} />\n//         <TimeAgo timestamp={post.date} />\n//       </div>\n//       <p className=\"post-content\">{post.content.substring(0, 100)}</p>\n\n//       <ReactionButtons post={post} />\n//       <Link to={`/posts/${post.id}`} className=\"button muted-button\">\n//         View Post\n//       </Link>\n//     </article>\n//   )\n// }\n\n// RTK Query\nconst PostExcerpt = ({ post }) => { \n  return (\n    <article className=\"post-excerpt\" key={post.id}>\n      <h3>{post.title}</h3>\n      <div>\n        <PostAuthor userId={post.user} />\n        <TimeAgo timestamp={post.date} />\n      </div>\n      <p className=\"post-content\">{post.content.substring(0, 100)}</p>\n\n      <ReactionButtons post={post} />\n      <Link to={`/posts/${post.id}`} className=\"button muted-button\">\n        View Post\n      </Link>\n    </article>\n  )\n}\n\n\n\n// export const PostsList = () => {\n//   const dispatch = useDispatch();\n  \n//   // Компоненты React читают данные из хранилища с помощью useSelector хука\n//   // const posts = useSelector(state => state.posts); // state.posts необходимый для работы срез данных\n//   // const posts = useSelector(selectAllPosts); // useSelector -> store.getState() -> корневой state -> selectorAllPosts(state) -> profit\n//   const orderedPostIds = useSelector(selectPostIds)\n\n//   const postStatus = useSelector((state) => state.posts.status);\n//   const error = useSelector((state) => state.posts.error);\n\n//   useEffect(() => {\n//     if(postStatus === 'idle') {\n//       dispatch(fetchPosts())\n//     }\n//   }, [postStatus, dispatch]);\n\n//   let content;\n\n//   if (postStatus === 'loading') {\n//     content = <Spinner text=\"Loading...\" />\n//   } else if (postStatus === 'succeeded') {\n//     content = orderedPostIds.map((postId) => (<PostExcerpt key={postId} postId={postId} />))\n//   } else if (postStatus === 'failed') {\n//     content = <div>{error}</div>\n//   }\n\n//   return (\n//     <section className=\"post-list\">\n//       <h2>Posts</h2>\n//       {content}\n//     </section>\n//   )\n// }  \n\n// с RTK Query\nexport const PostsList = () => {\n  // Сигнатура ответа от запроса на фейковый сервер\n  const {\n    // data: posts, // Это поле будет undefined до тех пор, пока не будет получен ответ .\n    data: posts = [],\n    isLoading, // Если запрос выполняется в первые true, в дальнейшем всегда будет false\n    isFetching, // Если запрос выполняется true, если нет, то false\n    isSuccess,\n    isError,\n    error,\n    refetch // фун. для повторного получения данных из запроса\n  } = useGetPostsQuery(); // Выполняем запрос на фековый сервер .../fakeApi/posts\n\n  const sortedPosts = useMemo(() => {\n    const sortedPosts = posts.slice();\n    // Мы не можем просто вызвать posts.sort()напрямую, потому что Array.sort() изменяет существующий массив, \n    // поэтому нам нужно сначала сделать его копию. Чтобы избежать повторной сортировки при каждом повторном рендеринге\n    \n    sortedPosts.sort((a, b) => b.date.localeCompare(a.date));\n    return sortedPosts;\n  }, [posts]);\n\n  let content;\n\n  if (isLoading) {\n    content = <Spinner text=\"Loading...\" />\n  } else if (isSuccess) {\n    const renderPosts = sortedPosts.map((post) => (\n      <PostExcerpt key={post.id} post={post} />\n    ));\n    \n    const containerClassname = cn('posts-container', {\n      disabled: isFetching\n    });\n\n    content = <div className={containerClassname}>{renderPosts}</div>\n  } else if (isError) {\n    content = <div>{error.toString()}</div>\n  }\n\n  return (\n    <section className=\"posts-list\">\n      <h2>Posts</h2>\n      <button onClick={refetch}>Refetch Posts</button>\n      {content}\n    </section>\n  )\n}  \n\n// Концептуально <PostsList> он по-прежнему выполняет ту же работу, что и раньше,\n// но мы смогли заменить множественные вызовы useSelector и useEffect диспетчеризацию \n// одним вызовом useGetPostsQuery().","import React, { useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { addNewPost } from './postsSlice.js';\nimport { selectAllUsers } from '../users/usersSlice.js';\n\n// export const AddPostForm = () => {\n//   const [title, setTitle] = useState('');\n//   const [content, setContent] = useState('');\n//   const [userId, setUserId] = useState('');\n//   const [requestStatus, setRequestStatus] = useState('idle'); // idle === бездействует\n\n//   const dispatch = useDispatch();\n\n//   // const users = useSelector(state => state.users);\n//   const users = useSelector(selectAllUsers);\n\n//   const onTitleChanged = e => setTitle(e.target.value);\n//   const onContentChanged = e => setContent(e.target.value);\n//   const onAuthorChanged = e => setUserId(e.target.value);\n\n//   const canSave = [title, content, userId].every(Boolean) && requestStatus === 'idle';\n//   const onSavePostClicked = async () => {\n//     if (canSave) {\n//       try {\n//         setRequestStatus('pending');\n\n\n//         // unwrap INFO: https://redux.js.org/tutorials/essentials/part-5-async-logic#checking-thunk-results-in-components\n//         await dispatch(addNewPost({ title, content, user:userId })).unwrap();\n//         // Redux-toolkit добавляет метод .unwrap() к возвращаемому Promise. Исп. этого метода возвр. еще один промис \n//         // содержащий результат action.payload в случае fulfilled или помогает всплытию ошибки в случае rejected.\n//         // Это позволяет нам обрабатывать успехи и неудачи в компоненте, используя обычную try/catch логику.\n//         // Грубо говоря .unwrap() в зависимости что вернул промис в поле action.type дописывает .then с доп логикой\n\n//         // Пример того, что будет заменять использование функции unwrap (пример условный):\n//         // Если промис вернул экшн в котором action.type === \"posts/addNewPost/fulfilled\", тогда\n//         // dispatch(...) + .then((action) => action.payload), если исп. с await то можно сразу получить наружу содержимое\n\n//         // Если промис вернул экшн в котором action.type === \"posts/addNewPost/rejected\", тогда\n//         // dispatch(...) + .then(action => {throw action.error.message}) - ошибка всплывает и уже обрабатывается try/catch (await никак не влияет на всплытие)\n//         // в моем случае await нужен для того, чтобы очистка полей произошла после того, как выполнился thunk, не важно с каким результатом.\n\n//         setTitle('');\n//         setContent('');\n//         setUserId('');\n//       } catch (err) {\n\n//         // Если результат dispatch(addNewPost) - rejected, unwrap позволит не проглатить ошибку внутри промиса, \n//         // а поднять её наружу и обрабатываем тут! Это очень важно!\n//         console.error('Failed to save the post: ', err)\n//         // Если вы хотите посмотреть, что произойдет, если addNewPostвызов API завершится ошибкой, попробуйте создать новый пост, \n//         // в котором в поле «Содержание» будет только слово «error» (без кавычек). Сервер увидит это и отправит ответ с ошибкой, \n//         // поэтому вы должны увидеть сообщение, зарегистрированное на консоли. \n//         // Это поможет понять как работает .unwrap() в случае ошибки. \n//         // Т.е. попробовать await dispatch(addNewPost({ title, content, user:userId }))\".unwrap()\" и без неё\n\n//       } finally {\n//         setRequestStatus('idle');\n//       }\n//     }\n//   }\n\n//   const usersOptions = users.map(user => (\n//     <option key={user.id} value={user.id}>\n//       {user.name}\n//     </option>\n//   ))\n\n//   return (\n//     <section>\n//       <h2>Add a New Post</h2>\n//       <form>\n//         <label htmlFor=\"postTitle\">Post Title:</label>\n//         <input\n//           type=\"text\"\n//           id=\"postTitle\"\n//           name=\"postTitle\"\n//           value={title}\n//           onChange={onTitleChanged}\n//         />\n//         <label htmlFor=\"postAuthor\">Author:</label>\n//         <select id=\"postAuthor\" value={userId} onChange={onAuthorChanged}>\n//           <option value=\"\"></option>\n//           {usersOptions}\n//         </select>\n//         <label htmlFor=\"postContent\">Content:</label>\n//         <textarea\n//           id=\"postContent\"\n//           name=\"postContent\"\n//           value={content}\n//           onChange={onContentChanged}\n//         />\n//         <button type=\"button\" onClick={onSavePostClicked} disabled={!canSave}>Save Post</button>\n//       </form>\n//     </section>\n//   )\n// }\n\n\n\n// C RTK Query\nimport { useAddNewPostMutation, } from '../api/apiSlice';\n\nexport const AddPostForm = () => {\n  const [title, setTitle] = useState('');\n  const [content, setContent] = useState('');\n  const [userId, setUserId] = useState('');\n  const [requestStatus, setRequestStatus] = useState('idle'); // idle === бездействует\n\n  const [addNewPost, { isLoading }] = useAddNewPostMutation();\n\n  const users = useSelector(selectAllUsers);\n\n  // form handlers\n  const onTitleChanged = e => setTitle(e.target.value);\n  const onContentChanged = e => setContent(e.target.value);\n  const onAuthorChanged = e => setUserId(e.target.value);\n\n  const canSave = [title, content, userId].every(Boolean) && !isLoading;\n\n  const onSavePostClicked = async () => {\n    if (canSave) {\n      try {\n        await addNewPost({ title, content, user: userId }).unwrap();\n        setTitle('');\n        setContent('');\n        setUserId('');\n      } catch (err) {\n        // Если результат dispatch(addNewPost) - rejected, unwrap позволит не проглатить ошибку внутри промиса, \n        // а поднять её наружу и обрабатываем тут! Это очень важно!\n        console.error('Failed to save the post: ', err)\n        // Если вы хотите посмотреть, что произойдет, если addNewPostвызов API завершится ошибкой, попробуйте создать новый пост, \n        // в котором в поле «Содержание» будет только слово «error» (без кавычек). Сервер увидит это и отправит ответ с ошибкой, \n        // поэтому вы должны увидеть сообщение, зарегистрированное на консоли. \n        // Это поможет понять как работает .unwrap() в случае ошибки. \n        // Т.е. попробовать await dispatch(addNewPost({ title, content, user:userId }))\".unwrap()\" и без неё\n\n      } finally {\n        setRequestStatus('idle');\n      }\n    }\n  }\n\n  const usersOptions = users.map(user => (\n    <option key={user.id} value={user.id}>\n      {user.name}\n    </option>\n  ))\n\n  return (\n    <section>\n      <h2>Add a New Post</h2>\n      <form>\n        <label htmlFor=\"postTitle\">Post Title:</label>\n        <input\n          type=\"text\"\n          id=\"postTitle\"\n          name=\"postTitle\"\n          value={title}\n          onChange={onTitleChanged}\n        />\n        <label htmlFor=\"postAuthor\">Author:</label>\n        <select id=\"postAuthor\" value={userId} onChange={onAuthorChanged}>\n          <option value=\"\"></option>\n          {usersOptions}\n        </select>\n        <label htmlFor=\"postContent\">Content:</label>\n        <textarea\n          id=\"postContent\"\n          name=\"postContent\"\n          value={content}\n          onChange={onContentChanged}\n        />\n        <button type=\"button\" onClick={onSavePostClicked} disabled={!canSave}>Save Post</button>\n      </form>\n    </section>\n  )\n}\n","import React from 'react';\n// import { useSelector } from 'react-redux';\nimport { Link } from 'react-router-dom';\nimport { PostAuthor } from './PostAuthor';\nimport { TimeAgo } from './TimeAgo';\nimport { ReactionButtons } from './ReactionButtons';\n// import { selectPostById } from './postsSlice';\n\nimport { Spinner } from '../../components/Spinner'\nimport { useGetPostQuery } from '../api/apiSlice';\n\n// export const SinglePostPage = ({ match }) => {\n//   const { postId } = match.params;\n\n//   // const post = useSelector(state => state.posts.find(post => post.id === postId));\n//   const post = useSelector((state) => selectPostById(state, postId));\n\n//   if (!post) {\n//     return (\n//       <section>\n//         <h2>Post not found!</h2>\n//       </section>\n//     )\n//   }\n\n//   return (\n//     <section>\n//       <article className=\"post\">\n//         <h2>{post.title}</h2>\n//         <div>\n//           <PostAuthor userId={post.user} />\n//           <TimeAgo timestamp={post.date} />\n//         </div>\n//         <p className=\"post-content\">{post.content}</p>\n//         <ReactionButtons post={post} />\n//         <Link to={`/editPost/${post.id}`} className=\"button\" style={{marginTop: '15px'}}>\n//           Edit Post\n//         </Link>\n//       </article>\n//     </section>\n//   )\n// }\n\n// С RTK Query\nexport const SinglePostPage = ({ match }) => {\n  const { postId } = match.params;\n\n  const { data: post = [], isFetching, isSuccess } = useGetPostQuery(postId);\n\n  let content;\n\n  if (isFetching) {\n    content = <Spinner text='loading' />;\n  } else if (isSuccess) {\n    content = (\n      <article className=\"post\">\n        <h2>{post.title}</h2>\n        <div>\n          <PostAuthor userId={post.user} />\n          <TimeAgo timestamp={post.date} />\n        </div>\n        <p className=\"post-content\">{post.content}</p>\n        <ReactionButtons post={post} />\n        <Link to={`/editPost/${post.id}`} className=\"button\" style={{ marginTop: '15px' }}>\n          Edit Post\n        </Link>\n      </article>\n    )\n  }\n\n  return <section>{content}</section>;\n}","import { useDispatch, useSelector } from 'react-redux';\nimport React, { useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { postUpdated, selectPostById } from './postsSlice.js';\n\n// export const EditPostForm = ({ match }) => {\n//   const { postId } = match.params;\n\n//   // const post = useSelector((state) => \n//     // state.posts.find(post => post.id === postId));\n//   const post = useSelector((state) => selectPostById(state, postId));\n\n//   const [title, setTitle] = useState(post.title);\n//   const [content, setContent] = useState(post.content);\n\n//   const dispatch = useDispatch();\n//   const history = useHistory();\n\n//   const onTitleChanged = (e) => setTitle(e.target.value);\n//   const onContentChanged = (e) => setContent(e.target.value);\n//   const onSavePostClicked = () => {\n//     if (title && content) {\n//       dispatch(postUpdated({ id: postId, title, content }));\n//       history.push(`/posts/${postId}`)\n//     }\n//   }\n\n//   return (\n//     <section>\n//       <h2>Edit Post</h2>\n//       <form>\n//         <label htmlFor=\"postTitle\">Post Title:</label>\n//         <input\n//           type=\"text\"\n//           id=\"postTitle\"\n//           name=\"postTitle\"\n//           placeholder=\"What's on your mind?\"\n//           value={title}\n//           onChange={onTitleChanged}\n//         />\n//         <label htmlFor=\"postContent\">Content:</label>\n//         <textarea\n//           id=\"postContent\"\n//           name=\"postContent\"\n//           value={content}\n//           onChange={onContentChanged}\n//         />\n//       </form>\n//       <button type=\"button\" onClick={onSavePostClicked}>\n//         Save Post\n//       </button>\n//     </section>\n//   )\n// }\n\n\n// С RTK Query\nimport { useGetPostQuery, useEditPostMutation } from '../api/apiSlice';\n\nexport const EditPostForm = ({ match }) => {\n  const { postId } = match.params;\n\n  const { data: post } = useGetPostQuery(postId);\n  const [updatePost, { isLoading }] = useEditPostMutation();\n\n  const [title, setTitle] = useState(post.title);\n  const [content, setContent] = useState(post.content);\n\n  const history = useHistory();\n\n  const onTitleChanged = (e) => setTitle(e.target.value);\n  const onContentChanged = (e) => setContent(e.target.value);\n\n  const onSavePostClicked = async () => {\n    if (title && content) {\n      await updatePost({ id: postId, title, content });\n      history.push(`/posts/${postId}`);\n    }\n  }\n\n  return (\n    <section>\n      <h2>Edit Post</h2>\n      <form>\n        <label htmlFor=\"postTitle\">Post Title:</label>\n        <input\n          type=\"text\"\n          id=\"postTitle\"\n          name=\"postTitle\"\n          placeholder=\"What's on your mind?\"\n          value={title}\n          onChange={onTitleChanged}\n        />\n        <label htmlFor=\"postContent\">Content:</label>\n        <textarea\n          id=\"postContent\"\n          name=\"postContent\"\n          value={content}\n          onChange={onContentChanged}\n        />\n      </form>\n      <button type=\"button\" onClick={onSavePostClicked}>\n        Save Post\n      </button>\n    </section>\n  )\n}","import { useSelector } from \"react-redux\";\nimport { selectUserById } from \"./usersSlice\";\nimport { selectPostByUser  } from '../posts/postsSlice.js';\nimport { Link } from 'react-router-dom';\n\nexport const UserPage = ({ match }) => {\n  const { userId } = match.params;\n  \n  const user = useSelector((state) => selectUserById(state, userId));\n \n\n  // Когда мы вызываем useSelector() он подписывается на хранилище Redux.\n  // Это значит, что useSelector будет запускаться всякий раз, когда в хранилище было отпрвлено действие,\n  // даже не важно из какого компонента.\n\n  // const postsForUser = useSelector(state => {\n  //   const allPosts = selectAllPosts(state)\n  //   return allPosts.filter(post => post.user === userId) <=== https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\n  //   Так делать нельзя, это ломает прицип работы useSelector.\n  //   Метод filter возвратит ссылку на новый массив. После каждого вызова (кроме самого первого), useSelector\n  //   Выполняет поверхностное сравнение (===) прошлого возвращенного значения и текущего, но т.к. мы всегда возвращаем\n  //   новую ссылку, т.е. прошлое значение !== текущему, это приведет к лишнему рендеру компонента, даже не смотря на то,\n  //   что у обоих сравниваемых значений одинаковое содержимое,но разные ссылки.\n  // })\n\n  // 1 - useSelector запоминает результат прошлого вызова, это значит, что селектор должен возвращать \n  // одну и ту же ссылку если значение не поменялось.\n  \n  // 2 - Всегда передавать в селектор одну и туже функцию, т.е. так, чтобы её ссылка не менялась после рендера компонента.\n  // В моем случае функцию селектора (selectAllPosts) выведена в отдельный файл (или можно вывести за рамки функционального компонента),\n  // где ссылка на функцию не будет менятся при рендере компонента.\n  \n  const postsForUser = useSelector((state) => selectPostByUser(state, userId));\n  // selectPostByUser - Мемоизированные селектор созданный при помощи createSelector, теперь не стоит беспокоится о проблемах выше\n  // Если мы попытаемся вызвать selectPostsByUserнесколько раз, он будет повторно запускать селектор вывода только в том случае, если что-либо postsили userId изменилось\n  \n  const postTitles = postsForUser.map((post) => (\n    <li key={post.id}>\n      <Link to={`/posts/${post.id}`}>{post.title}</Link>\n    </li>\n  ));\n\n  return (\n    <section>\n      <h2>{user.name}</h2>\n\n      <ul>{postTitles}</ul>\n    </section>\n  )\n}","import { useSelector } from \"react-redux\";\nimport { Link } from 'react-router-dom';\n\nimport { selectAllUsers } from './usersSlice.js';\n\nexport const UsersList = () => {\n  const users = useSelector(selectAllUsers);\n\n  const renderUsers = users.map((user) => (\n    <li key={user.id}>\n      <Link to={`/users/${user.id}`}>{user.name}</Link>\n    </li>\n  ));\n\n  return (\n    <section>\n      <h2>Users</h2>\n\n      <ul>{renderUsers}</ul>\n    </section>\n  )\n}","import { useLayoutEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { parseISO, formatDistanceToNow } from 'date-fns';\nimport classnames from 'classnames';\nimport { selectAllNotifications, allNotificationsRead  } from './notificationsSlice.js';\nimport { selectAllUsers } from '../users/usersSlice.js';\n\nexport const NotificationsList = () => {\n  const dispatch = useDispatch();\n  const notifications = useSelector(selectAllNotifications);\n  const users = useSelector(selectAllUsers);\n\n  useLayoutEffect(() => {\n    dispatch(allNotificationsRead());    \n  })\n\n  const renderNotifications = notifications.map((notification) => {\n    const date = parseISO(notification.date);\n    const timeAgo = formatDistanceToNow(date);\n    const user = users.find((user) => user.id === notifications.user) || { name: 'Unknown User' };\n    const notificationClassname = classnames('notification', {\n      new: notification.isNew,\n    })\n    return (\n      <div key={notification.id} className={notificationClassname}>\n        <div>\n          <b>{user.name}</b> {notification.message}\n        </div>\n        <div title={notification.date}>\n          <i>{timeAgo} ago</i>\n        </div>\n      </div>\n    )\n  })\n\n  return (\n    <section className=\"notificationList\">\n      <h2>Notification</h2>\n      {renderNotifications}\n    </section>\n  )\n}","import React from 'react'\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  // Redirect,\n} from 'react-router-dom'\n\nimport { Navbar } from './app/Navbar'\nimport { PostsList } from './features/posts/PostsList.js';\nimport { AddPostForm } from './features/posts/AddPostForm.js';\nimport { SinglePostPage } from './features/posts/SinglePostPage.js';\nimport { EditPostForm } from './features/posts/EditPostForm.js';\nimport { UserPage } from './features/users/UserPage.js';\nimport { UsersList } from './features/users/UsersList.js';\nimport { NotificationsList } from './features/notifications/NotificationsList';\n\nfunction App() {\n  return (\n    <Router>\n      <Navbar />\n      <div className=\"App\">\n        <Switch>\n          <Route exact path=\"/\" render={() =>\n            <>\n              <AddPostForm />\n              <PostsList />\n            </>\n          }\n          />\n          <Route exact path='/posts/:postId' component={SinglePostPage} />\n          <Route exact path=\"/editPost/:postId\" component={EditPostForm} />\n          <Route exact path='/users' component={UsersList} />\n          <Route exact path='/users/:userId' component={UserPage} />\n          <Route exact path='/notifications' component={NotificationsList} />\n          {/* <Redirect to=\"/\" /> */}\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n\nexport default App\n","import { rest, setupWorker } from 'msw'\nimport { factory, oneOf, manyOf, primaryKey } from '@mswjs/data'\nimport { nanoid } from '@reduxjs/toolkit'\nimport faker from 'faker'\nimport seedrandom from 'seedrandom'\nimport { Server as MockSocketServer } from 'mock-socket'\nimport { setRandom } from 'txtgen'\n\nimport { parseISO } from 'date-fns'\n\nconst NUM_USERS = 3\nconst POSTS_PER_USER = 3\nconst RECENT_NOTIFICATIONS_DAYS = 7\n\n// Add an extra delay to all endpoints, so loading spinners show up.\nconst ARTIFICIAL_DELAY_MS = 2000\n\n/* RNG setup */\n\n// Set up a seeded random number generator, so that we get\n// a consistent set of users / entries each time the page loads.\n// This can be reset by deleting this localStorage value,\n// or turned off by setting `useSeededRNG` to false.\nlet useSeededRNG = true\n\nlet rng = seedrandom()\n\nif (useSeededRNG) {\n  let randomSeedString = localStorage.getItem('randomTimestampSeed')\n  let seedDate\n\n  if (randomSeedString) {\n    seedDate = new Date(randomSeedString)\n  } else {\n    seedDate = new Date()\n    randomSeedString = seedDate.toISOString()\n    localStorage.setItem('randomTimestampSeed', randomSeedString)\n  }\n\n  rng = seedrandom(randomSeedString)\n  setRandom(rng)\n  faker.seed(seedDate.getTime())\n}\n\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(rng() * (max - min + 1)) + min\n}\n\nconst randomFromArray = (array) => {\n  const index = getRandomInt(0, array.length - 1)\n  return array[index]\n}\n\n/* MSW Data Model Setup */\n\nexport const db = factory({\n  user: {\n    id: primaryKey(nanoid),\n    firstName: String,\n    lastName: String,\n    name: String,\n    username: String,\n    posts: manyOf('post'),\n  },\n  post: {\n    id: primaryKey(nanoid),\n    title: String,\n    date: String,\n    content: String,\n    reactions: oneOf('reaction'),\n    comments: manyOf('comment'),\n    user: oneOf('user'),\n  },\n  comment: {\n    id: primaryKey(String),\n    date: String,\n    text: String,\n    post: oneOf('post'),\n  },\n  reaction: {\n    id: primaryKey(nanoid),\n    thumbsUp: Number,\n    hooray: Number,\n    heart: Number,\n    rocket: Number,\n    eyes: Number,\n    post: oneOf('post'),\n  },\n})\n\nconst createUserData = () => {\n  const firstName = faker.name.firstName()\n  const lastName = faker.name.lastName()\n\n  return {\n    firstName,\n    lastName,\n    name: `${firstName} ${lastName}`,\n    username: faker.internet.userName(),\n  }\n}\n\nconst createPostData = (user) => {\n  return {\n    title: faker.lorem.words(),\n    date: faker.date.recent(RECENT_NOTIFICATIONS_DAYS).toISOString(),\n    user,\n    content: faker.lorem.paragraphs(),\n    reactions: db.reaction.create(),\n  }\n}\n\n// Create an initial set of users and posts\nfor (let i = 0; i < NUM_USERS; i++) {\n  const author = db.user.create(createUserData())\n\n  for (let j = 0; j < POSTS_PER_USER; j++) {\n    const newPost = createPostData(author)\n    db.post.create(newPost)\n  }\n}\n\nconst serializePost = (post) => ({\n  ...post,\n  user: post.user.id,\n})\n\n/* MSW REST API Handlers */\n\nexport const handlers = [\n  rest.get('/fakeApi/posts', function (req, res, ctx) {\n    const posts = db.post.getAll().map(serializePost)\n    return res(ctx.delay(ARTIFICIAL_DELAY_MS), ctx.json(posts))\n  }),\n  rest.post('/fakeApi/posts', function (req, res, ctx) {\n    const data = req.body\n\n    if (data.content === 'error') {\n      return res(\n        ctx.delay(ARTIFICIAL_DELAY_MS),\n        ctx.status(500),\n        ctx.json('Server error saving this post!')\n      )\n    }\n\n    data.date = new Date().toISOString()\n\n    const user = db.user.findFirst({ where: { id: { equals: data.user } } })\n    data.user = user\n    data.reactions = db.reaction.create()\n\n    const post = db.post.create(data)\n    return res(ctx.delay(ARTIFICIAL_DELAY_MS), ctx.json(serializePost(post)))\n  }),\n  rest.get('/fakeApi/posts/:postId', function (req, res, ctx) {\n    const post = db.post.findFirst({\n      where: { id: { equals: req.params.postId } },\n    })\n    return res(ctx.delay(ARTIFICIAL_DELAY_MS), ctx.json(serializePost(post)))\n  }),\n  rest.patch('/fakeApi/posts/:postId', (req, res, ctx) => {\n    const { id, ...data } = req.body\n    const updatedPost = db.post.update({\n      where: { id: { equals: req.params.postId } },\n      data,\n    })\n    return res(\n      ctx.delay(ARTIFICIAL_DELAY_MS),\n      ctx.json(serializePost(updatedPost))\n    )\n  }),\n\n  rest.get('/fakeApi/posts/:postId/comments', (req, res, ctx) => {\n    const post = db.post.findFirst({\n      where: { id: { equals: req.params.postId } },\n    })\n    return res(\n      ctx.delay(ARTIFICIAL_DELAY_MS),\n      ctx.json({ comments: post.comments })\n    )\n  }),\n\n  rest.post('/fakeApi/posts/:postId/reactions', (req, res, ctx) => {\n    const postId = req.params.postId\n    const reaction = req.body.reaction\n    const post = db.post.findFirst({\n      where: { id: { equals: postId } },\n    })\n\n    const updatedPost = db.post.update({\n      where: { id: { equals: postId } },\n      data: {\n        reactions: {\n          ...post.reactions,\n          [reaction]: (post.reactions[reaction] += 1),\n        },\n      },\n    })\n\n    return res(\n      ctx.delay(ARTIFICIAL_DELAY_MS),\n      ctx.json(serializePost(updatedPost))\n    )\n  }),\n  rest.get('/fakeApi/notifications', (req, res, ctx) => {\n    const numNotifications = getRandomInt(1, 5)\n\n    let notifications = generateRandomNotifications(\n      undefined,\n      numNotifications,\n      db\n    )\n\n    return res(ctx.delay(ARTIFICIAL_DELAY_MS), ctx.json(notifications))\n  }),\n  rest.get('/fakeApi/users', (req, res, ctx) => {\n    return res(ctx.delay(ARTIFICIAL_DELAY_MS), ctx.json(db.user.getAll()))\n  }),\n]\n\nexport const worker = setupWorker(...handlers)\n// worker.printHandlers() // Optional: nice for debugging to see all available route handlers that will be intercepted\n\n/* Mock Websocket Setup */\n\nconst socketServer = new MockSocketServer('ws://localhost')\n\nlet currentSocket\n\nconst sendMessage = (socket, obj) => {\n  socket.send(JSON.stringify(obj))\n}\n\n// Allow our UI to fake the server pushing out some notifications over the websocket,\n// as if other users were interacting with the system.\nconst sendRandomNotifications = (socket, since) => {\n  const numNotifications = getRandomInt(1, 5)\n\n  const notifications = generateRandomNotifications(since, numNotifications, db)\n\n  sendMessage(socket, { type: 'notifications', payload: notifications })\n}\n\nexport const forceGenerateNotifications = (since) => {\n  sendRandomNotifications(currentSocket, since)\n}\n\nsocketServer.on('connection', (socket) => {\n  currentSocket = socket\n\n  socket.on('message', (data) => {\n    const message = JSON.parse(data)\n\n    switch (message.type) {\n      case 'notifications': {\n        const since = message.payload\n        sendRandomNotifications(socket, since)\n        break\n      }\n      default:\n        break\n    }\n  })\n})\n\n/* Random Notifications Generation */\n\nconst notificationTemplates = [\n  'poked you',\n  'says hi!',\n  `is glad we're friends`,\n  'sent you a gift',\n]\n\nfunction generateRandomNotifications(since, numNotifications, db) {\n  const now = new Date()\n  let pastDate\n\n  if (since) {\n    pastDate = parseISO(since)\n  } else {\n    pastDate = new Date(now.valueOf())\n    pastDate.setMinutes(pastDate.getMinutes() - 15)\n  }\n\n  // Create N random notifications. We won't bother saving these\n  // in the DB - just generate a new batch and return them.\n  const notifications = [...Array(numNotifications)].map(() => {\n    const user = randomFromArray(db.user.getAll())\n    const template = randomFromArray(notificationTemplates)\n    return {\n      id: nanoid(),\n      date: faker.date.between(pastDate, now).toISOString(),\n      message: template,\n      user: user.id,\n    }\n  })\n\n  return notifications\n}\n","import { configureStore } from '@reduxjs/toolkit';\nimport postsReducer from '../features/posts/postsSlice.js';\nimport usersReducer from '../features/users/usersSlice.js';\nimport notificationsSlice from '../features/notifications/notificationsSlice.js';\nimport { apiSlice } from '../features/api/apiSlice';\n\nexport default configureStore({\n  reducer: {\n    posts: postsReducer,\n    users: usersReducer,\n    notifications: notificationsSlice,\n    [apiSlice.reducerPath]: apiSlice.reducer\n  },\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware().concat(apiSlice.middleware)\n    // - это сделано, чтобы сохранить предыдущие redux-thunk (fetchPost fetchUsers fetchNotif...)\n    // из каждого среза (слайса) и в тоже время применить вновь созданный мидлвар из apiSlice\n})\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport store from './app/store'\nimport { Provider } from 'react-redux'\n\nimport { fetchUsers } from './features/users/usersSlice.js';\n\nimport { worker } from './api/server'\n\n// Wrap app rendering so we can wait for the mock API to initialize\nasync function start() {\n  // Start our mock API server\n  await worker.start({ onUnhandledRequest: 'bypass' })\n\n  store.dispatch(fetchUsers());\n  \n  ReactDOM.render(\n    <React.StrictMode>\n      <Provider store={store}>\n        <App />\n      </Provider>\n    </React.StrictMode>,\n    document.getElementById('root')\n  )\n}\n\nstart()\n"],"sourceRoot":""}